#!/usr/bin/env bash

# Lint Go code
# Usage:
# `go_lint`
# `go_lint ./...`
# `go_lint dir1 dir2/... dir3/file1.go`
# `go_lint --new-from-rev=HEAD~1 ./...`
# `go_lint --new-from-rev=e5925f4 path/to/package`
function go_lint() {
    golangci-lint run --config ~/.golangci.yml "$@"
}

# Set the go version
# Usage:
# `go_set [from] [to]`
# `go_set go@1.12 go@1.13`
function go_set() {
    brew unlink "$1"
    brew link "$2" --force
}

# Git compare two branches
function git_compare() {
    hub compare "$@"
}

# Starts Vault server using the passed config
# Usage:
# vault_server config-file.hcl
vault_server() {
    vault server -config="$1" > /tmp/vault.log 2>&1 &
}

# Tunnel Vault API/UI over SSH
# Usage:
# `vault_tun <username>@<remote-address>`
vault_tun() {
    # ssh -N -L <local-port>:<remote-address>:<remote-port> <username>@<remote-address>
    ssh -N -L 8200:127.0.0.1:8200 "$@"
}

# Vault cluster helper functions
vault_1() {
    VAULT_ADDR=http://127.0.0.1:8200 vault "$@"
}
vault_2() {
    VAULT_ADDR=http://127.0.0.2:8200 vault "$@"
}
vault_3() {
    VAULT_ADDR=http://127.0.0.3:8200 vault "$@"
}
vault_4() {
    VAULT_ADDR=http://127.0.0.4:8200 vault "$@"
}

# Clean all docker volumes
function docker_clean() {
    docker volume rm "$(docker volume ls -qf dangling=true)"
}

# Kill all docker containers
function docker_killall() {
    docker rm -f "$(docker ps -a -q)"
}

# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$_"
}

# Copy current directory to clipboard on macOS
function pwdcp() {
    pwd | pbcopy
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null >/dev/null 2>&1; then
        local arg=-sbh
    else
        local arg=-sh
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@"
    else
        du $arg .[^.]* ./*
    fi
}

# Create a data URL from a file
function dataurl() {
    local mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Compare original and gzipped file size
function gz() {
    local origsize=$(wc -c <"$1")
    local gzipsize=$(gzip -c "$1" | wc -c)
    local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
    printf "orig: %d bytes\n" "$origsize"
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Run `dig` and display the most useful info
function digg() {
    dig +nocmd "$1" any +multiline +noall +answer
}

# Show all the names (CNs and SANs) listed in the SSL certificate for a given domain
function getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified."
        return 1
    fi

    local domain="${1}"
    echo "Testing ${domain}â€¦"
    echo "" # newline

    local tmp=$(echo -e "GET / HTTP/1.0\nEOT" |
        openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)

    if [[ "${tmp}" == *"-----BEGIN CERTIFICATE-----"* ]]; then
        local certText=$(echo "${tmp}" |
            openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version")
        echo "Common Name:"
        echo "" # newline
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
        echo "" # newline
        echo "Subject Alternative Name(s):"
        echo "" # newline
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" |
            sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
        return 0
    else
        echo "ERROR: Certificate not found."
        return 1
    fi
}
